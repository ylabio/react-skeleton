# Сервисы

Сервисы - это инициализированные модули системы, точнее - объекты, одиночные экземпляры классов. 
Могут иметь любую логику, своё состояние, обращаться к другим сервисам. 
Для использования сервиса не нужно выполнять его импорт и задумываться про его инициализацию. 
Так как инициализация выполняется автоматически самим сервисом (менеджером сервисов) 
при первом обращении к сервису по его названию.

*Примеры сервисов: управление состоянием (store, redux, mobx...), доступ к АПИ, 
обертки к апи браузера, любые функции с предварительной инициализацией или состоянием.*

### Новый сервис

Сервис описывается классом и должен иметь метод init() и defaultConfig(). Лучше воспользоваться
наследованием абстрактного класса `Service`. Файлы сервиса можно разместить в папке `@src/services`
или в папке `@src/features`, если сервис реализует конкретную бизнес задачу.

```ts
import Service from "@src/services/service";

class SomeService extends Service {
  // любые свойства и методы
}

export default SomeService;
```

### Настройки сервиса

Если у сервиса будут настройки, то нужно указать их тип в дженерике 
и определить значения по умолчанию методом defaultConfig. Можно будет учесть переменные окружения,
а при рендере на сервере учесть ещё параметры обрабатываемого запроса (они будут в `env.req`).

```ts
class SomeService extends Service<TSomeServiceConfig> {
  defaultConfig(env: ImportMetaEnv): TSomeServiceConfig {
    return {
      someOption: env.DEV ? 'defaultValue' : 'prodValue'
    };
  }
}

type TSomeServiceConfig = {
  someOption: string
}
```

Настройки можно будет указать в файле `@src/config.ts` по названию сервиса.

```ts
export default (env : ImportMetaEnv): TServicesConfig => ({
  //...
  some: {
    someOption: 'realValue'
  },
});
```

Итоговые настройки сервиса находятся в свойстве `this.config`. К переменным окружения можно обратиться
через свойство сервиса `this.env`


### Подключение сервиса

Новый сервис нужно прописать в файле импорта всех сервисов: `@src/services/imports.ts`. Импорт
асинхронный.

```ts
export default {
  //...
  some: () => import('@src/services/some'),
};
```

### Инициализация сервиса

Если сервису требуется инициализация при первом обращении к нему, то реализуется (переопределяется)
метод `init()` 

```ts
class SomeService extends Service<TSomeServiceConfig> {
  init()  {
    // инициализация, что-то считаем, куда-то подключаемся
  }
}
```

В метод `init(dump?: unknown)` может быть передан дамп состояния сервиса. Дамп передаётся менеджером
сервиса при автоматической инициализации, а сам дамп появляется после рендера на сервере. Но чтобы
дамп появился, сервис его должен уметь возвращать методом `dump()`. Таким образом реализуется 
восстановление состояния любого сервиса после рендера на сервере. Дампы от
всех сервисов собирает сам менеджер сервисов, получает их от сервера и передаёт соответствующему
сервису при его инициализации. Тип дампа (состояния) нужно указать в дженерирке класса.

```ts
class SomeService extends Service<TSomeServiceConfig, TSomeState> {
  state: TSomeState;
  
  init(dump?: unknown)  {
    // Проврека типа dump
    if (isSomeState(dump)) this.state = dump;
  }

  dump(): TSomeState {
    return this.state;
  }
}


```

### Взаимодействие сервисов

Доступ к другому сервису осуществляется напрямую по названию сервиса (без инъекции зависимостей),
через менеджер сервиса. Возможно, этот кейс стоит доработать, но он приведет к дополнительным 
абстракциям.

Менеджер сервисов создаётся в корне приложения один раз. И выполняется асинхронная инициализация
менеджера, чтобы выполнилась динамическая загрузка самих сервисов. После инициализации менеджера 
можно обращаться к любому сервису и запускать необходимую логику. 

Ссылка для доступа к сервисам передаётся в контекст React приложения. 

```tsx
// Инициализация менеджера сервисов
const servicesManager = new Services(env);
// Через services получаем доступ к store, api, i18n и всем другим сервисам
const services = await servicesManager.init(clientConfig(env));

const Root = () => (
  <ServicesProvider services={services}>
    <App/>
  </ServicesProvider>
);
//...
```
К сервисам из компонента можно обратиться через хук `useServices()`.

```tsx
import useServices from "@src/services/use-services";
import useInit from "./use-init";

function Component() {

  const some = useServices().some;

  useInit(async () => {
    await some.doSomething();
  });

  //return...
}
```

В конструктор каждого сервиса передаётся **ссылка на все сервисы** (прокси объект). Она сохраняется
в свойстве `this.services`. Через неё и выполняется доступ к любому сервису.

```ts
class SomeService extends Service<TSomeServiceConfig> {
  
  async doSomething(){
    // Обращаемся к севрису api, чтобы выполнить запрос
    // Сервис АПИ при этом можем иметь состояние - предустановленные заголвоки с учётом авторизаци и i18n
    const result = await this.services.api.request('http://example.ylab.io/api/xxx')
  }
}
```

## `useInit()`

Вспомогательный хук для выполнения асинхронной инициализации в компоненте. По сути заменяет хук
`useEffect`, но учитываются особенности рендера на сервере, чтобы дожидаться инициализации перед
рендером. Чтобы ожидание учитывалось на сервере, в хук нужно передать ключ `ssr`.
Значением может быть название (описание) выполняемого действия. 
Ключ необходим для идентификации ожидания и последующей синхронизации его на клиенте. 
Если SSR не используется, то ключ можно не указывать и использовать хук для семантики. 
Чтобы ожидание корректно работало нужно также использовать async/await (чтобы функция вернула Promise).

```ts
// Если использует SSR, то при первым рендере на клиенте (при гидрации) 
// useInit не будет лишний раз выполняться. 
// Но при смене зависимостей useInit корректно выполнится.
useInit(async () => {
  await services.store.modules.categories.load({fields: '*', limit: 1000});
}, [], {ssr: 'categories.load'});
```

## `types.ts`

Все типы выводятся автоматически на основе импортированных сервисов `@src/services/imports.ts`.
